# 如何理解JS异步编程，事件循环，消息队列，宏/微任务？

## 总述

要从 "JavaScript 是单线程、异步、非阻塞、解释型脚本语言" 说起

 - JavaScript 单线程指的是浏览器中负责解释和执行 JavaScript 代码的只有一个线程，即为JS引擎线程，而浏览器的渲染进程提供了多个线程，如事件触发线程，定时触发器线程，异步http请求线程等。

 - 当遇到计时器、DOM事件监听或者是网络请求的任务时，JS引擎会将它们直接交给 webapi，也就是浏览器提供的相应线程（如定时器线程为setTimeout计时、异步http请求线程处理网络请求）去处理，而JS引擎线程继续后面的其他任务，这样便实现了 **异步非阻塞**。

 - 比如说，定时器触发线程也只是为 setTimeout(..., 1000) 定时而已，时间一到，还会把它对应的回调函数(callback)交给 **消息队列** 去维护，JS引擎线程会在适当的时候去消息队列取出消息并执行。

 - JavaScript 通过 **事件循环（Eventloop）** 的机制来解决这个问题。

## 事件循环 与 消息队列

 - 事件循环 机制和 消息队列 的维护是由 **事件触发线程** 控制的。

 - 事件触发线程 同样是浏览器渲染引擎提供的，它会维护一个 消息队列。

 - JS引擎线程遇到异步，会交给相应的线程单独去维护异步任务，等待某个时机，然后由 事件触发线程 将异步对应的 回调函数 加入到消息队列中，消息队列中的回调函数等待被执行。

 - JS引擎线程会维护一个 执行栈，同步代码会依次加入执行栈然后执行，结束会退出执行栈

 - 如果执行栈里的任务执行完成，即执行栈为空的时候（即JS引擎线程空闲），事件触发线程才会从消息队列取出一个任务（即异步的回调函数）放入执行栈中执行。

 - 执行完了后，执行栈再次为空，事件触发线程会重复上一步操作，再取出一个消息队列中的任务，这种机制就被称为**事件循环（event loop）机制**。

 
## 宏/微任务

 - 宏任务：主代码块、setTimeout、setInterval等（可以看到，事件队列中的每一个事件都是一个 macrotask，现在称之为宏任务队列）

 - 微任务：Promise、process.nextTick等

 - 每次执行栈执行的代码就是一个宏任务，包括任务队列(宏任务队列)中的，因为执行栈中的宏任务执行完会去取任务队列（宏任务队列）中的任务加入执行栈中，即同样是事件循环的机制。在执行宏任务时遇到Promise等，会创建微任务（.then()里面的回调），并加入到微任务队列队尾。

 - 在某一个 宏任务 执行完后，在重新渲染与开始下一个宏任务之前，就会将在它执行期间产生的所有 微任务 都执行完毕

 